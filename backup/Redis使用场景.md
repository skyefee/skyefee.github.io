### 缓存
看场景使用，下面说几个场景
1、作只读缓存使用的话（大部分的场景都是作为只读缓存使用：例如优惠券策略等），有些情况会设置缓存时间，有些不会设置缓存时间
	更新走db，缓存走删除（可以防止ABA）
	设置了缓存时间的话（注意缓存雪崩、缓存击穿）；没设置缓存时间（注意存储）
	缓存除了删除，也可以走更新，但是走更新的话需要考虑的问题就比较多，如果需要强一致性的话，可能需要加锁进行处理，同步更新，但是也需要考虑更新失败后如果处理，是进行回滚还是进行异步更新/删除？看使用场景
2、作读写缓存，这个场景不算太多吧，相当于把缓存当db使用，这个场景主要是读写相当/写多于读，相对于上面的场景，若写请求大于读请求，频繁的删除缓存，再从db中读取写入缓存，相当于缓存失效或没有发挥缓存该有的效果。
场景1：打点，我们会对一些特殊的动作点位进行上报，比如说下单、支付、个人中心等等，计算一些pv和uv，这种场景其实不需要非常的实时，但是写请求是很多的，每次请求都对db操作，数据库还是有一些压力的，我们的做法是使用缓存把这些点位缓存起来，后台任务定时刷新到db
场景2：作库存，扣减库存/回滚库存直接更新redis，使用redis的单线程的特性，减少业务层面锁的介入，后面异步线程/协程同步库存信息到db中

### 布隆过滤器
特性：有，是可能有；无，是肯定无
多个hash函数散列更新
场景1：解决缓存穿透
场景2：黑名单

### 分布式锁